library(readxl)
library(dplyr)
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
data_path <- "../data/combined_Data_imm.csv"
Combined_Data <- read.csv(data_path)
## <--------------------------------------------------------------------------->
## Kalman Filter: Univariate SSMs for Population Growth
## <--------------------------------------------------------------------------->
## Transition equation:
## alpha[t+1] = Growth rate * alpha[t] + immigration[t], eta[t] ~ N(0, HHt)
## Measurement equation:
## y[t] = alpha[t] + eps[t], eps[t] ~  N(0, GGt)
# Define the parameters (phi, beta)
phi <- mean(1 - (Combined_Data$Death_Count / Combined_Data$Population))
beta <- mean(Combined_Data$Birth_Count / Combined_Data$Population)
years <- Combined_Data$Year
# Constant factor of 1 in measurement equation
Zt <- matrix(1, nrow = 1, ncol = 1)
# Initial state and variance
a0 <- as.double(Combined_Data$Population[!is.na(Combined_Data$Population)][1]) # Initial state
P0 <- matrix(1000) # Initial variance
# Constant factor of state transition matrix
Tt <- matrix(phi + beta, nrow = 1, ncol = 1)
# Observation noise (Set as 3% of the mean population count)
GGt_Default <- matrix(mean(0.03 * Combined_Data$Population), nrow = 1, ncol = 1)
########################
# Observed population
y <- Combined_Data$Population
yt <- rbind(y)
yt[is.na(yt)] <- 0 # Replace NA with 0 for Kalman filtering
dt <- matrix(as.double(Combined_Data$Immigration_Count),nrow = 1)
ct <- matrix(0) # intercepts of the transition and measurement equations
# Process noise
# Approximate with the variance of the yearly differences in population
yearly_differences <- diff(na.omit(Combined_Data$Population))
process_noise_estimate <- (var(yearly_differences))
HHt_Default <- matrix(process_noise_estimate)
################################################################################################################
# Fit Kalman Filter and Plot
run_kalman_and_plot <- function(a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt, years, data, plot_title) {
kf <- fkf(a0 = a0, P0 = P0, dt = dt, ct = ct, Tt = Tt, Zt = Zt, HHt = HHt, GGt = GGt, yt = yt)
log_likelihood <- kf$logLik
print(paste("Log-likelihood:", log_likelihood))
# Extract the filtered state estimates
filtered_estimates <- as.numeric(kf$att)
# Calculate standard errors (square root of diagonal elements of Ptt)
standard_errors <- list()
# Loop through each time point in the array
for (i in 1:dim(kf$Ptt)[3]) {
# Extract the standard error (square root of the variance)
se <- (kf$Ptt[1, 1, i])
# Append to the list
standard_errors[i] <- as.numeric(se)
}
standard_errors_vector <- unlist(standard_errors)
# Compute 95% Confidence Interval
ci_upper <- filtered_estimates + (1.96 * standard_errors_vector)
ci_lower <- filtered_estimates - (1.96 * standard_errors_vector)
# Convert the Kalman Filter estimates and Confidence Interval to a data frame for plotting
kf_df <- data.frame(Year = years, Estimated_Population = filtered_estimates,
CI_Upper = ci_upper, CI_Lower = ci_lower)
# Combine with the true population data
Combined_Plot_Data <- left_join(data, kf_df, by = "Year")
# Plotting with Confidence Interval
ggplot() +
geom_point(data = Combined_Plot_Data, aes(x = Year, y = Population), color = "blue", size = 2) +
geom_line(data = Combined_Plot_Data, aes(x = Year, y = Estimated_Population), color = "red") +
geom_ribbon(data = Combined_Plot_Data, aes(x = Year, ymin = ci_lower, ymax = ci_upper), alpha = 0.5, fill = "grey") +
theme_minimal()+
labs(title = plot_title) # Adding title to the plot
}
source("optimizeKalmanParams.R")
optimized_HHt <- optimize_kalman_params(yt, Tt, Zt, a0, P0, dt, ct, HHt_Default, GGt_Default)
run_kalman_and_plot(a0, P0, dt, ct, Tt, Zt, HHt_Default, GGt_Default, yt, years, Combined_Data, 'Default process noise')
run_kalman_and_plot(a0, P0, dt, ct, Tt, Zt, optimized_HHt, GGt_Default, yt, years, Combined_Data, 'Optimized process noise')
# Define the parameters (phi, beta)
phi <- mean(1 - (Combined_Data$Death_Count / Combined_Data$Population))
beta <- mean(Combined_Data$Birth_Count / Combined_Data$Population)
years <- Combined_Data$Year
# Constant factor of 1 in measurement equation
Zt <- matrix(1, nrow = 1, ncol = 1)
# Initial state and variance
a0 <- as.double(Combined_Data$Population[!is.na(Combined_Data$Population)][1]) # Initial state
P0 <- matrix(1000) # Initial variance
# Constant factor of state transition matrix
Tt <- matrix(phi + beta, nrow = 1, ncol = 1)
# Observation noise (Set as 3% of the mean population count)
GGt_Default <- matrix(mean(0.03 * Combined_Data$Population), nrow = 1, ncol = 1)
########################
# Observed population
y <- Combined_Data$Population
yt <- rbind(y)
yt[is.na(yt)] <- 0 # Replace NA with 0 for Kalman filtering
dt <- matrix(as.double(Combined_Data$Immigration_Count),nrow = 1)
ct <- matrix(0) # intercepts of the transition and measurement equations
# Process noise
# Approximate with the variance of the yearly differences in population
yearly_differences <- diff(na.omit(Combined_Data$Population))
process_noise_estimate <- (var(yearly_differences))
HHt_Default <- matrix(process_noise_estimate)
HHt_Default
################################################################################################################
# Fit Kalman Filter and Plot
run_kalman_and_plot <- function(a0, P0, dt, ct, Tt, Zt, HHt, GGt, yt, years, data, plot_title) {
kf <- fkf(a0 = a0, P0 = P0, dt = dt, ct = ct, Tt = Tt, Zt = Zt, HHt = HHt, GGt = GGt, yt = yt)
log_likelihood <- kf$logLik
print(paste("Log-likelihood:", log_likelihood))
# Extract the filtered state estimates
filtered_estimates <- as.numeric(kf$att)
# Calculate standard errors (square root of diagonal elements of Ptt)
standard_errors <- list()
# Loop through each time point in the array
for (i in 1:dim(kf$Ptt)[3]) {
# Extract the standard error (square root of the variance)
se <- (kf$Ptt[1, 1, i])
# Append to the list
standard_errors[i] <- as.numeric(se)
}
standard_errors_vector <- unlist(standard_errors)
# Compute 95% Confidence Interval
ci_upper <- filtered_estimates + (1.96 * standard_errors_vector)
ci_lower <- filtered_estimates - (1.96 * standard_errors_vector)
# Convert the Kalman Filter estimates and Confidence Interval to a data frame for plotting
kf_df <- data.frame(Year = years, Estimated_Population = filtered_estimates,
CI_Upper = ci_upper, CI_Lower = ci_lower)
# Combine with the true population data
Combined_Plot_Data <- left_join(data, kf_df, by = "Year")
# Plotting with Confidence Interval
ggplot() +
geom_point(data = Combined_Plot_Data, aes(x = Year, y = Population), color = "blue", size = 2) +
geom_line(data = Combined_Plot_Data, aes(x = Year, y = Estimated_Population), color = "red") +
geom_ribbon(data = Combined_Plot_Data, aes(x = Year, ymin = ci_lower, ymax = ci_upper), alpha = 0.5, fill = "grey") +
theme_minimal()+
labs(title = plot_title) # Adding title to the plot
}
run_kalman_and_plot(a0, P0, dt, ct, Tt, Zt, HHt_Default, GGt_Default, yt, years, Combined_Data, 'Default process noise')
source("optimizeKalmanParams.R")
optimized_HHt <- optimize_kalman_params(yt, Tt, Zt, a0, P0, dt, ct, HHt_Default, GGt_Default)
?dpois
library(dplyr)
library(readxl)
################################################################################################################
# Set working directory
folder_path <- file.path(dirname(rstudioapi::getSourceEditorContext()$path), "/Users/liuzikai/Desktop/5758/Group Project")
setwd(folder_path)
Crab_Data <- read.csv('/Users/liuzikai/Desktop/5758/Group Project /CrabAgePrediction.csv')
View(Crab_Data)
head(Crab_Data)
Crab_Data$Is_Female <- ifelse(Crab_Data$Sex == 'F', 1, 0)  # 1 for females, 0 for others
# Now, you can prepare your data for PCA, excluding the original 'Sex' column but keeping 'Is_Female':
Crab_Data_PCA <- Crab_Data[, -1]  # Removes the original 'Sex' column
Crab_Data_PCA <- Crab_Data_PCA[, -8]  # Optionally, remove 'Age' if it's not part of PCA
View(Crab_Data_PCA)
View(Crab_Data)
# The rest of the PCA process remains the same:
pca_result <- prcomp(Crab_Data_PCA, scale. = TRUE)
biplot(pca_result)
# Assuming 'pca_result' is the result of your PCA
set.seed(123) # Setting seed for reproducibility
sample_size <- 300 # Define your desired sample size
# Create a sample of indices
sample_indices <- sample(nrow(Crab_Data_PCA), sample_size)
# Extract the scores for the sample
pca_scores_sample <- pca_result$x[sample_indices, ]
biplot(pca_result, cex=0.6)
points(pca_result$x[,1:2], col="grey", cex=0.3) # Plot all points in grey
points(pca_scores_sample[,1:2], col="red", pch=16)
View(pca_result)
sample_size <- 30 # Define your desired sample size
# Create a sample of indices
sample_indices <- sample(nrow(Crab_Data_PCA), sample_size)
# Extract the scores for the sample
pca_scores_sample <- pca_result$x[sample_indices, ]
biplot(pca_result, cex=0.6)
points(pca_result$x[,1:2], col="grey", cex=0.3) # Plot all points in grey
points(pca_scores_sample[,1:2], col="red", pch=16)
set.seed(123)  # Set a random seed for reproducibility
sample_size <- 30  # Define the sample size
# Assuming you have the 'Crab_Data' already read in and it's a dataframe
Crab_Data_Sample <- Crab_Data[sample(1:nrow(Crab_Data), sample_size), ]
# Now, conduct PCA on just the sample
pca_result_sample <- prcomp(Crab_Data_Sample[, -c(1, 9)], scale. = TRUE)  # Exclude non-numeric 'Sex' and 'Age'
# Plot the biplot for the PCA results of the sample
biplot(pca_result_sample)
# For clustering analyses (k-means and hierarchical), ensure to include the 'Is_Female' variable if it's relevant to your analysis. Here's an example with k-means clustering including 'Is_Female':
kmeans_result <- kmeans(Crab_Data_PCA, centers=3)
View(kmeans_result)
plot_df <- data.frame(PC1 = pca_for_plot$x[, 1],
PC2 = pca_for_plot$x[, 2],
Cluster = as.factor(kmeans_result$cluster))
# For clustering analyses (k-means and hierarchical), ensure to include the 'Is_Female' variable if it's relevant to your analysis. Here's an example with k-means clustering including 'Is_Female':
kmeans_result <- kmeans(Crab_Data_PCA, centers=3)
plot_df <- data.frame(PC1 = pca_result$x[, 1],
PC2 = pca_result$x[, 2],
Cluster = as.factor(kmeans_result$cluster))
plot(PC1 ~ PC2, data = plot_df, col = plot_df$Cluster, pch = 19,
xlab = "Principal Component 1", ylab = "Principal Component 2",
main = "K-means Clustering with 3 Centers")
centers <- pca_for_plot$rotation[, 1:2] %*% t(kmeans_result$centers)
centers <- pca_result$rotation[, 1:2] %*% t(kmeans_result$centers)
# Scatterplot Matrix
pairs(Crab_Data_PCA)
library(GGally)
# Scatterplot Matrix
ggpairs(Crab_Data_PCA)
# Scatterplot Matrix
ggpairs(Crab_Data_Sample)
# Scatterplot Matrix
paris(Crab_Data_Sample)
# Scatterplot Matrix
pairs(Crab_Data_Sample)
# Scatterplot Matrix
pairs(Crab_Data_Sample[, -c(1, 9)])
# Scatterplot Matrix
Crab_Data_Sample_Plot <- Crab_Data_Sample[, -c(1, 9)]
pairs(Crab_Data_Sample_Plot)
# Parallel coordinates
Crab_Data_PCA_normalized <- as.data.frame(scale(Crab_Data_Sample_Plot))
ggparcoord(data = Crab_Data_PCA_normalized, columns = 1:ncol(Crab_Data_PCA_normalized), groupColumn = NULL)
library(aplpack)
# Chernoff Faces
faces(Crab_Data_PCA_normalized)
View(Crab_Data)
# Correlation matrix
cor(Crab_Data_Sample_Plot)
library(corrplot)
# Correlation matrix
corrplot(cor(Crab_Data_Sample_Plot),method = 'circle')
# Correlation matrix
corrplot(cor(Crab_Data),method = 'circle')
# Correlation matrix
corrplot(cor(Crab_Data_PCA),method = 'circle')
dist_matrix <- dist(Crab_Data_PCA)  # Compute the distance matrix
mds_result <- cmdscale(dist_matrix)  # Apply MDS
# Plot the MDS result
plot(mds_result[,1], mds_result[,2], xlab="Dimension 1", ylab="Dimension 2", main="MDS Plot", type="n")
text(mds_result[,1], mds_result[,2], labels=row.names(Crab_Data_PCA))
##############################################
# Set working directory
folder_path <- file.path(dirname(rstudioapi::getSourceEditorContext()$path), "/Group Project ")
setwd(folder_path)
Crab_Data <- read.csv('CrabAgePrediction.csv')
Crab_Data$Is_Female <- ifelse(Crab_Data$Sex == 'F', 1, 0)  # 1 for females, 0 for others
Crab_Data_PCA <- Crab_Data[, -1]  # Removes the original 'Sex'
Crab_Data_PCA <- Crab_Data_PCA[, -8]  # Optionally, remove 'Age'
##############################################
# PCA on sample
set.seed(123)
sample_size <- 30
Crab_Data_Sample <- Crab_Data[sample(1:nrow(Crab_Data), sample_size), ]
Crab_Data_Sample_Plot <- Crab_Data_Sample[, -c(1, 9)]
pca_result_sample <- prcomp(Crab_Data_Sample_Plot, scale. = TRUE)
# Plot the biplot for the PCA results of the sample
biplot(pca_result_sample)
##############################################
# Scatterplot Matrix
pairs(Crab_Data_Sample_Plot)
##############################################
# Correlation matrix
corrplot(cor(Crab_Data_PCA),method = 'circle')
# Scatterplot Matrix (Sample Data)
pairs(Crab_Data_Sample_Plot)
?biplot
biplot(pca_result_sample, main = 'PCA Biplot for 30 Sample Data')
biplot(pca_result_sample, main = 'PCA Biplot for a Sample of 30 Data')
##############################################
# Correlation matrix
corrplot(cor(Crab_Data_PCA),method = 'circle', main = 'Correlation Matrix with Encoded Sex')
##############################################
# Correlation matrix
corrplot(cor(Crab_Data_PCA),method = 'circle')
##############################################
# Correlation matrix
corrplot(cor(Crab_Data),method = 'circle')
View(Crab_Data)
##############################################
# Correlation matrix
Crab_Data_Corr <-  Crab_Data[, -1]
corrplot(cor(Crab_Data_Corr),method = 'circle')
library(tidyverse)
library(dplyr)
library(ggplot2)
# Read the data
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
data_path <- "../data/combined_Data_imm.csv"
data <- read.csv(data_path)
bayesian_particle_filter_adjusted <- function(data, num_particles = 10000, birth_rate_prior = c(0, 0.1), death_rate_prior = c(0, 0.1), thresh = 0.9) {
# Initialize particles
sdo <- 0.015 * data$Population[nrow(data) - 1]
birth_rate_particles  <- rnorm(num_particles, birth_rate_prior[1], birth_rate_prior[2])
death_rate_particles <- rnorm(num_particles, death_rate_prior[1], death_rate_prior[2])
# Ensure particles between (0,1)
birth_rate_particles <- pmin(pmax(birth_rate_particles, 0), 1)
death_rate_particles <- pmin(pmax(death_rate_particles, 0), 1)
weights <- rep(1/num_particles, num_particles)
estimated_parameters_and_population <- data.frame()
for (year in 2:nrow(data)) {
prev_population <- data[year - 1, 'Population']
observed_population <- data[year, 'Population']
# Simulate process model with changes:
died <- rbinom(num_particles, prev_population, death_rate_particles)  # Binomial death
survived <- prev_population - died                                   # Survivors
births <- rpois(num_particles, lambda = survived * birth_rate_particles) # Poisson birth
estimated_population <- survived + births + data[year, "Immigration_Count"]
# Add normal variation for observation error
estimated_population <- estimated_population + rnorm(num_particles, 0, prev_population * 0.01)
# Update weights
# weights <- weights * dpois(observed_population, estimated_population)
weights <- weights * dlnorm(observed_population, meanlog = log(estimated_population), sdlog = sdo) # Adjust this line if sdo calculation changes
weights <- weights + 1e-300
weights <- weights / sum(weights)
# Resample particles
ess <- sum(weights^2) * num_particles # Calculate Effective Sample Size
if (ess < num_particles * thresh) { # Resample if ESS below threshold
indices <- sample(1:num_particles, size = num_particles, replace = TRUE, prob = weights)
birth_rate_particles <- birth_rate_particles[indices]
death_rate_particles <- death_rate_particles[indices]
weights <- rep(1/num_particles, num_particles) # Reset weights after resampling
}
# Estimate parameters
estimated_birth_rate <- mean(birth_rate_particles)
estimated_death_rate <- mean(death_rate_particles)
# Calculate Confidence Intervals
lower_CI <- quantile(estimated_population, probs = 0.025)
upper_CI <- quantile(estimated_population, probs = 0.975)
estimated_parameters_and_population <- rbind(estimated_parameters_and_population, data.frame(
Year = data[year, 'Year'],
Estimated_birth_Rate = estimated_birth_rate,
Estimated_Death_Rate = estimated_death_rate,
Observed_Population = observed_population,
Estimated_Population = mean(estimated_population),
Lower_CI = lower_CI,
Upper_CI = upper_CI,
ESS = ess
))
}
return(estimated_parameters_and_population)
}
# Applying the adjusted Bayesian particle filter
adjusted_bayesian_estimated_population_df <- bayesian_particle_filter_adjusted(data)
# Plotting the results
ggplot(adjusted_bayesian_estimated_population_df, aes(x = Year)) +
geom_line(aes(y = Observed_Population, color = "Actual Population")) +
geom_line(aes(y = Estimated_Population, color = "Estimated Population")) +
geom_ribbon(aes(ymin = Lower_CI, ymax = Upper_CI), alpha = 0.3, col = "grey") +
xlab('Year') +
ylab('Population') +
ggtitle('Particle Filtering Hard-Coded') +
scale_color_manual(values = c('Actual Population' = 'blue', 'Estimated Population' = 'red')) +
theme_minimal()
ggplot(adjusted_bayesian_estimated_population_df, aes(x = Year, y = ESS)) +
geom_line() +
ggtitle("Evolution of Effective Sample Size (ESS)") +
xlab("Year") +
ylab("ESS") +
theme_minimal()
library(tidyverse)
library(dplyr)
library(ggplot2)
# Read the data
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
data_path <- "../data/combined_Data_imm.csv"
data <- read.csv(data_path)
sdo <- 0.015 * data$Population[length(data$Population) - 1]
bayesian_particle_filter_adjusted <- function(data, num_particles = 10000, birth_rate_prior = c(0, 0.1), death_rate_prior = c(0, 0.1), thresh = 0.9) {
# Initialize particles
# sdo <- 0.015 * data$Population[nrow(data) - 1]
birth_rate_particles  <- rnorm(num_particles, birth_rate_prior[1], birth_rate_prior[2])
death_rate_particles <- rnorm(num_particles, death_rate_prior[1], death_rate_prior[2])
# Ensure particles between (0,1)
birth_rate_particles <- pmin(pmax(birth_rate_particles, 0), 1)
death_rate_particles <- pmin(pmax(death_rate_particles, 0), 1)
weights <- rep(1/num_particles, num_particles)
estimated_parameters_and_population <- data.frame()
for (year in 2:nrow(data)) {
prev_population <- data[year - 1, 'Population']
observed_population <- data[year, 'Population']
# Simulate process model with changes:
died <- rbinom(num_particles, prev_population, death_rate_particles)  # Binomial death
survived <- prev_population - died                                   # Survivors
births <- rpois(num_particles, lambda = survived * birth_rate_particles) # Poisson birth
estimated_population <- survived + births + data[year, "Immigration_Count"]
# Add normal variation for observation error
estimated_population <- estimated_population + rnorm(num_particles, 0, prev_population * 0.01)
# Update weights
# weights <- weights * dpois(observed_population, estimated_population)
weights <- weights * dlnorm(observed_population, meanlog = log(estimated_population), sdlog = sdo) # Adjust this line if sdo calculation changes
weights <- weights + 1e-300
weights <- weights / sum(weights)
# Resample particles
ess <- sum(weights^2) * num_particles # Calculate Effective Sample Size
if (ess < num_particles * thresh) { # Resample if ESS below threshold
indices <- sample(1:num_particles, size = num_particles, replace = TRUE, prob = weights)
birth_rate_particles <- birth_rate_particles[indices]
death_rate_particles <- death_rate_particles[indices]
weights <- rep(1/num_particles, num_particles) # Reset weights after resampling
}
# Estimate parameters
estimated_birth_rate <- mean(birth_rate_particles)
estimated_death_rate <- mean(death_rate_particles)
# Calculate Confidence Intervals
lower_CI <- quantile(estimated_population, probs = 0.025)
upper_CI <- quantile(estimated_population, probs = 0.975)
estimated_parameters_and_population <- rbind(estimated_parameters_and_population, data.frame(
Year = data[year, 'Year'],
Estimated_birth_Rate = estimated_birth_rate,
Estimated_Death_Rate = estimated_death_rate,
Observed_Population = observed_population,
Estimated_Population = mean(estimated_population),
Lower_CI = lower_CI,
Upper_CI = upper_CI,
ESS = ess
))
}
return(estimated_parameters_and_population)
}
# Applying the adjusted Bayesian particle filter
adjusted_bayesian_estimated_population_df <- bayesian_particle_filter_adjusted(data)
# Plotting the results
ggplot(adjusted_bayesian_estimated_population_df, aes(x = Year)) +
geom_line(aes(y = Observed_Population, color = "Actual Population")) +
geom_line(aes(y = Estimated_Population, color = "Estimated Population")) +
geom_ribbon(aes(ymin = Lower_CI, ymax = Upper_CI), alpha = 0.3, col = "grey") +
xlab('Year') +
ylab('Population') +
ggtitle('Particle Filtering Hard-Coded') +
scale_color_manual(values = c('Actual Population' = 'blue', 'Estimated Population' = 'red')) +
theme_minimal()
ggplot(adjusted_bayesian_estimated_population_df, aes(x = Year, y = ESS)) +
geom_line() +
ggtitle("Evolution of Effective Sample Size (ESS)") +
xlab("Year") +
ylab("ESS") +
theme_minimal()
library(tidyverse)
library(dplyr)
library(ggplot2)
# Read the data
setwd(dirname(rstudioapi::getSourceEditorContext()$path))
data_path <- "../data/combined_Data_imm.csv"
data <- read.csv(data_path)
sdo <- 0.015 * data$Population[length(data$Population) - 1]
bayesian_particle_filter_adjusted <- function(data, num_particles = 10000, birth_rate_prior = c(0, 0.1), death_rate_prior = c(0, 0.1), thresh = 0.9) {
# Initialize particles
# sdo <- 0.015 * data$Population[nrow(data) - 1]
birth_rate_particles  <- rnorm(num_particles, birth_rate_prior[1], birth_rate_prior[2])
death_rate_particles <- rnorm(num_particles, death_rate_prior[1], death_rate_prior[2])
# Ensure particles between (0,1)
birth_rate_particles <- pmin(pmax(birth_rate_particles, 0), 1)
death_rate_particles <- pmin(pmax(death_rate_particles, 0), 1)
weights <- rep(1/num_particles, num_particles)
estimated_parameters_and_population <- data.frame()
for (year in 2:nrow(data)) {
prev_population <- data[year - 1, 'Population']
observed_population <- data[year, 'Population']
# Simulate process model with changes:
died <- rbinom(num_particles, prev_population, death_rate_particles)  # Binomial death
survived <- prev_population - died                                   # Survivors
births <- rpois(num_particles, lambda = survived * birth_rate_particles) # Poisson birth
estimated_population <- survived + births + data[year, "Immigration_Count"]
# Add normal variation for observation error
estimated_population <- estimated_population + rnorm(num_particles, 0, prev_population * 0.01)
# Update weights
weights <- weights * dpois(observed_population, estimated_population)
# weights <- weights * dlnorm(observed_population, meanlog = log(estimated_population), sdlog = sdo) # Adjust this line if sdo calculation changes
weights <- weights + 1e-300
weights <- weights / sum(weights)
# Resample particles
ess <- sum(weights^2) * num_particles # Calculate Effective Sample Size
if (ess < num_particles * thresh) { # Resample if ESS below threshold
indices <- sample(1:num_particles, size = num_particles, replace = TRUE, prob = weights)
birth_rate_particles <- birth_rate_particles[indices]
death_rate_particles <- death_rate_particles[indices]
weights <- rep(1/num_particles, num_particles) # Reset weights after resampling
}
# Estimate parameters
estimated_birth_rate <- mean(birth_rate_particles)
estimated_death_rate <- mean(death_rate_particles)
# Calculate Confidence Intervals
lower_CI <- quantile(estimated_population, probs = 0.025)
upper_CI <- quantile(estimated_population, probs = 0.975)
estimated_parameters_and_population <- rbind(estimated_parameters_and_population, data.frame(
Year = data[year, 'Year'],
Estimated_birth_Rate = estimated_birth_rate,
Estimated_Death_Rate = estimated_death_rate,
Observed_Population = observed_population,
Estimated_Population = mean(estimated_population),
Lower_CI = lower_CI,
Upper_CI = upper_CI,
ESS = ess
))
}
return(estimated_parameters_and_population)
}
# Applying the adjusted Bayesian particle filter
adjusted_bayesian_estimated_population_df <- bayesian_particle_filter_adjusted(data)
# Plotting the results
ggplot(adjusted_bayesian_estimated_population_df, aes(x = Year)) +
geom_line(aes(y = Observed_Population, color = "Actual Population")) +
geom_line(aes(y = Estimated_Population, color = "Estimated Population")) +
geom_ribbon(aes(ymin = Lower_CI, ymax = Upper_CI), alpha = 0.3, col = "grey") +
xlab('Year') +
ylab('Population') +
ggtitle('Particle Filtering Hard-Coded') +
scale_color_manual(values = c('Actual Population' = 'blue', 'Estimated Population' = 'red')) +
theme_minimal()
ggplot(adjusted_bayesian_estimated_population_df, aes(x = Year, y = ESS)) +
geom_line() +
ggtitle("Evolution of Effective Sample Size (ESS)") +
xlab("Year") +
ylab("ESS") +
theme_minimal()
